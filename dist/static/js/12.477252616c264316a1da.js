webpackJsonp([12],{"7Kd+":function(s,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var e={render:function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("v-layout",{attrs:{row:"",wrap:""}},[n("v-flex",{attrs:{xs12:""}},[n("v-card",[n("v-toolbar",{attrs:{color:"pink",dark:""}},[n("v-toolbar-title",[s._v("JavaScript This 的六道坎")]),s._v(" "),n("v-spacer")],1)],1)],1),s._v(" "),s._l(s.codeDatas,function(t,e){return n("v-flex",{key:e,attrs:{xs12:"","pa-1":""}},[n("v-card",{staticClass:"white--text",attrs:{color:"blue-grey darken-2"}},[n("v-container",{attrs:{fluid:"","grid-list-lg":""}},[n("v-layout",{attrs:{row:""}},[n("v-flex",[n("div",[n("div",{staticClass:"headline"},[s._v(s._s(t.title))]),s._v(" "),n("div",[s._v(" "+s._s(t.subtitle))]),s._v(" "),t.code?n("div",[n("codemirror",{attrs:{value:t.code}})],1):s._e(),s._v(" "),t.characteristic?n("div",[t.characteristic.advantage?n("v-list",{attrs:{"two-line":"",subheader:""}},[n("v-subheader",{staticClass:"teal--text"},[s._v("优点")]),s._v(" "),n("v-card",[n("v-card-text",{staticClass:"pl-5"},s._l(t.characteristic.advantage,function(t,e){return n("p",{staticClass:"text-sm-left"},[s._v(s._s(t))])}))],1)],1):s._e(),s._v(" "),n("v-divider"),s._v(" "),t.characteristic.defect?n("v-list",{attrs:{"two-line":"",subheader:""}},[n("v-subheader",{staticClass:"red--text"},[s._v("缺点")]),s._v(" "),n("v-card-text",{staticClass:"pl-5"},s._l(t.characteristic.defect,function(t,e){return n("p",{staticClass:"text-sm-left"},[s._v(s._s(t))])}))],1):s._e()],1):s._e()])])],1)],1)],1)],1)})],2)},staticRenderFns:[]},o=n("VU/8")({data:function(){return{codeDatas:[{title:"第一层：世界尽头",subtitle:"权力最小的大佬是作为备胎的存在，在普通情况下就是全局，浏览器里就是window；在use strict的情况下就是undefined。",code:"function showThis() {\n                console.log(this)\n              }\n              function showStrictThis() {\n                'use strict'\n                console.log(this)\n              }\n              showThis()  // window\n              showStrictThis() // undefined"},{title:"第二层：点石成金",subtitle:"如果用到this的那个函数是属于某个 context object 的，那么这个 context object 绑定到this。比如下面的例子，boss是returnThis的 context object ，或者说returnThis属于boss。",code:"let boss = {\n              name: 'boss',\n              returnThis() {\n                return this\n              }\n            }\n             console.log(boss.returnThis() === boss) // true\n             \n             "},{title:"再往下看",subtitle:"在boss2.returnThis里，使用this的函数是boss1.returnThis，所以this绑定到boss1； 在boss3.returnThis里，使用this的函数是returnThis，所以this绑定到备胎。",code:"let boss = {\n              name: 'boss',\n              returnThis() {\n                return this\n              }\n            }\n             console.log(boss.returnThis() === boss) // true\n             //============================================\n             //再往下看\n             let boss1 = {\n              name: 'boss1',\n              returnThis () {\n                return this\n              }\n            }\n            let boss2 = {\n              name: 'boss2',\n              returnThis() {\n                return boss1.returnThis()\n              }\n            }\n            let boss3 = {\n              name: 'boss3',\n              returnThis() {\n                let returnThis = boss1.returnThis\n                return returnThis()\n              }\n            }\n            boss1.returnThis() // boss1\n            boss2.returnThis() // boss1\n            boss3.returnThis() // window"},{title:"要想把this绑定到boss2怎么做呢？",subtitle:"没错，只要让使用this的函数是属于boss2就行。",code:"\n            let boss1 = {\n              name: 'boss1',\n              returnThis() {\n                console.log(this)\n              }\n            }\n            let boss2 = {\n              name: 'boss2',\n              returnThis: boss1.returnThis\n            }\n            boss2.returnThis() // boss2\n          "},{title:"第三层：指腹为婚",subtitle:"第三层大佬是Object.prototype.call和Object.prototype.apply，它们可以通过参数指定this。（注意this是不可以直接赋值的哦，this = 2会报ReferenceError。）",code:"function returnThis() {\n              return this\n            }\n            let boss1 = {\n              name: 'boss1'\n            }\n            returnThis() // window\n            returnThis.call(boss1) // boss1\n            returnThis.apply(boss1) // boss1\n          "},{title:"第四层：海誓山盟",subtitle:"第四层大佬是Object.prototype.bind，他不但通过一个新函数来提供永久的绑定，还会覆盖第三层大佬的命令。",code:"function returnThis() {\n              return this\n            }\n            let boss1 = {\n              name: 'boss1'\n            }\n            let boss1ReturnThis = returnThis.bind(boss1)\n            boss1ReturnThis() // boss1\n\n            let boss2 = {\n              name: 'boss2'\n            }\n            boss1ReturnThis.call(boss2) // boss1"},{title:"第五层：内有乾坤",subtitle:"一个比较容易忽略的会绑定this的地方就是new。当我们new一个函数时，就会自动把this绑定在新对象上，然后再调用这个函数。它会覆盖bind的绑定。",code:"function showThis() {\n                return this\n              }\n              showThis() // window\n              new showThis() // showThis\n              let boss1 = {\n                name: 'boss1'\n              }\n              showThis.call(boss1) // boss1\n              new showThis().call(boss1) // 报错TypeError\n              let boss1ShowThis = showThis.bind(boss1)\n              boss1ShowThis() // boss1\n              new boss1ShowThis() // boss1ShowThis"},{title:"第六层：军令如山",subtitle:"最后一个法力无边的大佬就是 ES2015 的箭头函数。箭头函数里的this不再妖艳，被永远封印到当前词法作用域之中，称作 Lexical this ，在代码运行前就可以确定。没有其他大佬可以覆盖。这样的好处就是方便让回调函数的this使用当前的作用域，不怕引起混淆。所以对于箭头函数，只要看它在哪里创建的就行。如果对 V8 实现的词法作用域感兴趣可以看看这里。",code:"function callback(cb) {\n                    cb()\n                  }\n                  callback(()=>{ console.log(this) })  // window\n                  let boss1 = {\n                    name: 'boss1',\n                    callback: callback,\n                    callback2(){\n                      (()=>{\n                        console.log(this)\n                      })\n                    }\n                  }\n                  boss1.callback(()=>{ console.log(this) }) // window\n                  boss1.callback2(()=>{ console.log(this) }) // boss1"},{title:"下面这种奇葩的使用方式就需要注意：",subtitle:"如果你不知道最后为什么会是 boss2，继续理解“对于箭头函数，只要看它在哪里创建”这句话。",code:"let returnThis = () => this\n              returnThis() // window\n              new returnThis() //TypeError\n\n              let boss1 = {\n                name: 'boss1',\n                returnThis() {\n                  let func = () => this\n                  return func()\n                }\n              }\n              returnThis.call(boss1) // window\n\n              let boss1ReturnThis = returnThis.bind(boss1)\n                boss1ReturnThis() // window\n                boss1.returnThis() // boss1\n\n              let boss2 = {\n                name: 'boss2',\n                returnThis: boss1.returnThis\n              }\n              boss2.returnThis() // boss2\n        "}]}}},e,!1,null,null,null);t.default=o.exports}});
//# sourceMappingURL=12.477252616c264316a1da.js.map