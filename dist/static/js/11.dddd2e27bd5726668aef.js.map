{"version":3,"sources":["webpack:///src/components/Javascript/Vuex.vue","webpack:///./src/components/Javascript/Vuex.vue?11d3","webpack:///./src/components/Javascript/Vuex.vue"],"names":["Javascript_Vuex","render","_vm","this","_h","$createElement","_c","_self","attrs","row","wrap","xs12","color","dark","_v","type","value","offset-xs1","staticClass","subheader","_l","item","index","key","title","avatar","on","click","$event","_s","sm6","src","height","two-line","fluid","grid-list-sm","offset-sm-1","d-flex","column","tile","flat","word","myItem","i","subtitle","code","_e","supplement","mySubWord","subcode","ruleCode","staticRenderFns","Component","__webpack_require__","normalizeComponent","data","items","active","vuexRules","codeDatas","codes","subWord","__webpack_exports__"],"mappings":"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","file":"static/js/11.dddd2e27bd5726668aef.js","sourcesContent":["<template>\n<v-layout row wrap>\n    <v-flex xs12>\n      \n      <v-card>\n        <v-toolbar color=\"pink\" dark>\n          \n          <v-toolbar-title>Vuex学习心得</v-toolbar-title>\n          <v-spacer></v-spacer>\n          \n        </v-toolbar>\n       \n      </v-card>\n    </v-flex>\n\n    <v-flex xs12>\n    \t <v-alert type=\"info\" :value=\"true\">\n\t      Vuex概念： Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\t    </v-alert>\n    </v-flex>\n\n\t\t\t<v-flex xs12  offset-xs1>\n      <v-card>\n        <v-toolbar color=\"teal\" dark>\n          \n          <v-toolbar-title class=\"text-xs-center\">什么是状态管理模式？</v-toolbar-title>\n          \n        </v-toolbar>\n        <v-list subheader>\n          \n          <v-list-tile avatar v-for=\"(item, index) in items\" :key=\"item.title\" @click=\"\">\n            \n            <v-list-tile-content class=\"pl-4\">\n              <v-list-tile-title>{{index+1}}. {{item.title}}</v-list-tile-title>\n            </v-list-tile-content>\n            \n          </v-list-tile>\n        </v-list>\n        <v-divider></v-divider>\n        <v-subheader>以下是一个表示 “单向数据流“理念的极简示意图</v-subheader>\n        \n\n      \n      </v-card>\n\n    </v-flex>\n\n\n    <v-flex xs12 sm6 offset-xs1 class=\"mt-1\">\n      <v-card>\n        <v-card-media src=\"https://vuex.vuejs.org/zh-cn/images/flow.png\" height=\"400px\">\n   \n        </v-card-media>\n\n          </v-card>\n          \n        </v-flex>\n   <v-flex xs12 offset-xs1 class=\"mt-1\">\n   \t\t<v-alert type=\"warning\" :value=\"true\">\n\t\t      注意： 但是，当我们的应用遇到多个组件共享状态时,单项数据流的简洁性很容易破坏：\n\t\t    </v-alert>\n\t\t    <v-list subheader>\n          \n          <v-list-tile avatar  @click=\"\">\n            \n            <v-list-tile-content class=\"pl-4\">\n              <v-list-tile-title>问题1:多个视图依赖于同一状态。</v-list-tile-title>\n\n            </v-list-tile-content>\n            \n          </v-list-tile>\n\t\t\t\t\t\n\t\t\t\t\t <v-list-tile avatar  @click=\"\">\n            \n            <v-list-tile-content class=\"pl-4\">\n              <v-list-tile-title> 问题2:来自不同视图的行为需要变更同一状态。</v-list-tile-title>\n\n            </v-list-tile-content>\n            \n          </v-list-tile>\t\n          \n        </v-list>\n\n    \t <v-alert type=\"info\" :value=\"true\">\n\t     因此我们需要把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们组件树构成了一个巨大的”视图“，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\n\t    </v-alert>\n    \t <v-alert type=\"info\" :value=\"true\">\n\t    通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。\n\t  </v-alert>\n\n<v-card>\n        <v-card-media src=\"https://vuex.vuejs.org/zh-cn/images/vuex.png\" height=\"700px\">\n   \n        </v-card-media>\n\n          </v-card>\n\n           <v-toolbar color=\"teal\" dark>\n          \n          <v-toolbar-title class=\"text-xs-center\">什么情况下我应该使用 Vuex？</v-toolbar-title>\n          \n        </v-toolbar>\n<v-alert type=\"success\" :value=\"true\">\n        如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。\n      </v-alert>\n    \n    <v-toolbar color=\"teal\" dark>\n          \n          <v-toolbar-title class=\"text-xs-center\">安装Vuex</v-toolbar-title>\n          \n        </v-toolbar>\n\n        \n\n         <v-list two-line>\n          <template>\n            <v-subheader>\n            \t<code class=\"mr-2\">npm install vuex --save </code>\n            \t<code>yarn add vuex</code>\n            </v-subheader>\n          </template>\n          <v-alert type=\"info\" :value=\"true\">在store/index.js文件中引用vuex文件 并且使用use使用vuex</v-alert>\n          <template>\n            <v-subheader>\n            \t<code class=\"mr-2\">import Vue from 'vue'</code>\n            \t<code class=\"mr-2\">import Vuex from 'vuex'</code>\n            \t<code>Vue.use(Vuex)</code>\n            </v-subheader>\n          </template>\n        </v-list>\n\n         <v-toolbar color=\"teal\" dark>\n          \n          <v-toolbar-title class=\"text-xs-center\">Vuex核心概念</v-toolbar-title>\n          \n        </v-toolbar>\n        <v-list>\n        \t<v-list-tile >\n            \t\t<v-btn color=\"info\">State</v-btn>\n            \t\t<v-btn color=\"info\">Getter</v-btn>\n            \t\t<v-btn color=\"info\">Mutation</v-btn>\n            \t\t<v-btn color=\"info\">Action</v-btn>\n            \t\t<v-btn color=\"info\">Module</v-btn>\n          </v-list-tile>\n        </v-list>\n   </v-flex>\n   <v-container fluid grid-list-sm offset-sm-1>\n    <v-layout row wrap>\n      <v-flex d-flex xs12 \n\t\t\t\tv-for=\"(item, index) in codeDatas\"\n\t\t\t\t:key=\"index\"\n\n      \t>\n        <v-layout column>\n          <v-flex d-flex>\n            <v-card color=\"blue-grey\" dark tile flat>\n              <v-card-text\n              >\n\n    \t \t\t\t\t<v-alert type=\"info\" :value=\"true\">\n    \t \t\t\t\t\t\t<v-btn color=\"indigo\">{{item.word}}</v-btn>{{item.title}}\n    \t \t\t\t\t</v-alert>\n\t\t\t\t\t\t<div v-for=\"(myItem, i) in item.codes\">\t\n\t\t\t\t\t\t\t<p>{{myItem.subtitle}}</p>\n\t\t\t\t\t\t\t\t<codemirror v-if=\"myItem.code\"\n             \t:value=\"myItem.code\"\n            >\n      \t\t\t\t\t</codemirror>\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t<v-alert type=\"warning\" v-if=\"item.supplement\" :value=\"true\">\n    \t \t\t\t\t\t\t{{item.supplement}}\n    \t \t\t\t\t</v-alert>\n      \t\t\t\t\t\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t<div v-for=\"(mySubWord, i) in item.subWord\" :key=\"i\">\n\t\t\t\t\t\t\t<v-alert type=\"info\" :value=\"true\">\n    \t \t\t\t\t\t\t<v-btn color=\"indigo\" v-if=\"mySubWord.title\">{{mySubWord.title}}</v-btn>{{mySubWord.subtitle}}\n    \t \t\t\t\t</v-alert>\n    \t \t\t\t\t\n    \t \t\t\t\t<codemirror v-if=\"mySubWord.subcode\"\n             \t:value=\"mySubWord.subcode\"\n            >\n      \t\t\t\t\t</codemirror>\n\t\t\t\t\t\t\t<v-alert type=\"warning\" v-if=\"mySubWord.supplement\" :value=\"true\">\n    \t \t\t\t\t\t\t{{mySubWord.supplement}}\n    \t \t\t\t\t</v-alert>\n\t\t\t\t\t\t</div>\n    \t \t\t\t\t\n              </v-card-text>\n            </v-card>\n          </v-flex>\n          \n        </v-layout>\n      </v-flex>\n      \n      \n      \n    </v-layout>\n\n  </v-container>\n  <v-flex xs12 >\n      <v-card>\n        <v-toolbar color=\"teal\" dark>\n          \n          <v-toolbar-title class=\"text-xs-center\">项目结构</v-toolbar-title>\n          \n        </v-toolbar>\n\n        <v-list subheader>\n          \n          <v-list-tile avatar v-for=\"(item, index) in vuexRules\" :key=\"item.title\" @click=\"\">\n            \n            <v-list-tile-content class=\"pl-4\">\n              <v-list-tile-title>{{index+1}}. {{item.title}}</v-list-tile-title>\n            </v-list-tile-content>\n            \n          </v-list-tile>\n        </v-list>\n        <v-divider></v-divider>\n         \n        \n      </v-card>\n      <v-card color=\"blue-grey\" dark tile flat>\n              <v-card-text\n              >\n\t\t\t\t\n    \t \t\t\t\t<v-alert type=\"info\" :value=\"true\">\n\n    \t \t\t\t\t\t只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n    \t \t\t\t\t</v-alert>\n    \t \t\t\t\t<v-alert type=\"warning\" :value=\"true\">\n    \t \t\t\t\t对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\n    \t \t\t\t</v-alert>\n    \t \t\t\t<codemirror \n             \t:value=\"ruleCode\"\n            >\n      \t\t\t\t\t</codemirror>\n    \t \t\t\t</v-card-text>\n    \t \t\t</v-card>\n    </v-flex>\n\n      <v-flex xs12 >\n      <v-card>\n        <v-toolbar color=\"teal\" dark>\n          \n          <v-toolbar-title class=\"text-xs-center\">路由懒加载</v-toolbar-title>\n          \n        </v-toolbar>\n         <v-card-text\n              >\n\t\t\t\t\n    \t \t\t\t\t<v-alert type=\"info\" :value=\"true\">\n\n    \t \t\t\t\t\t当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。\n    \t \t\t\t\t</v-alert>\n    \t \t\t\t\t<v-alert type=\"warning\" :value=\"true\">\n    \t \t\t\t\t结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\n    \t \t\t\t</v-alert>\n    \t \t\t\t<codemirror \n             \tvalue=\"const Foo = () => Promise.resolve({ /* 组件定义对象 */ })\"\n            >\n      \t\t\t\t\t</codemirror>\n\n      \t\t\t\t\t<v-alert type=\"info\" :value=\"true\">\n      \t\t\t\t\t\t\t第二，在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)：\n      \t\t\t\t\t</v-alert>\n      \t\t\t\t\t<codemirror \n             \tvalue=\"import('./Foo.vue') // 返回 Promise\"\n            >\n      \t\t\t\t\t</codemirror>\n\n      \t\t\t\t\t<v-alert type=\"warning\" :value=\"true\">\n    \t \t\t\t\t注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\n    \t \t\t\t</v-alert>\n    \t \t\t\t<v-alert type=\"info\" :value=\"true\">\n    \t \t\t\t\t结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。\n    \t \t\t\t</v-alert>\n    \t \t\t\t<codemirror \n             \tvalue=\"const Foo = () => import('./Foo.vue')\"\n            >\n      \t\t\t\t\t</codemirror>\n\n      \t\t\t\t\t<v-alert type=\"info\" :value=\"true\">\n    \t \t\t\t\t在路由配置中什么都不需要改变，只需要像往常一样使用 Foo：\n    \t \t\t\t</v-alert>\n    \t \t\t\t<codemirror \n             \tvalue=\"const router = new VueRouter({\n\t\t\t\t  routes: [\n\t\t\t\t    { path: '/foo', component: Foo }\n\t\t\t\t  ]\n\t\t\t\t})\"\n            >\n      \t\t\t\t\t</codemirror>\n    \t \t\t\t</v-card-text>\n      </v-card>\n    </v-flex>\n\n\n    <v-flex xs12 >\n      <v-card>\n        <v-toolbar color=\"teal\" dark>\n          \n          <v-toolbar-title class=\"text-xs-center\">把组件按组分块</v-toolbar-title>\n          \n        </v-toolbar>\n         <v-card-text\n              >\n\t\t\t\t\n    \t \t\t\t\t<v-alert type=\"info\" :value=\"true\">\n\n    \t \t\t\t\t\t有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)。\n    \t \t\t\t\t</v-alert>\n    \t \t\t\t\t\n    \t \t\t\t<codemirror \n             \tvalue=\"const Foo = () => import(/* webpackChunkName: 'group-foo' */ './Foo.vue')\n\t\t\t\tconst Bar = () => import(/* webpackChunkName: 'group-foo' */ './Bar.vue')\n\t\t\t\tconst Baz = () => import(/* webpackChunkName: 'group-foo' */ './Baz.vue')\n\t\t\t\"\n            >\n      \t\t\t\t\t</codemirror>\n      \t\t\t\t\t<v-alert type=\"warning\" :value=\"true\">\n    \t \t\t\t\tWebpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。\n    \t \t\t\t</v-alert>\n      \t\t\t\t</v-card-text>\n      \t\t\t</v-card>\n      \t\t</v-flex>\n\n  \n  </v-layout>\n\t\n</template>\n<script>\n\texport default {\n\t\t\tdata: ()=> ({\n\t\t\t\t  \n\t\t\t\titems: [\n          { active: true, title: 'state,驱动应用的数据源'},\n          { active: true, title: 'view,以声明方式将state映射到视图' },\n          { title: 'actions,响应式在view上的用户输入导致的状态变化' }\n          \n        ],\n        vuexRules: [\n          { active: true, title: '应用层级的状态应该集中到单个 store 对象中。'},\n          { active: true, title: '提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。' },\n          { title: '异步逻辑都应该封装到 action 里面。' }\n          \n        ],\n\t\t\t\truleCode: `\n\t\t\t\t├── index.html\n\t\t\t\t├── main.js\n\t\t\t\t├── api\n\t\t\t\t│   └── ... # 抽取出API请求\n\t\t\t\t├── components\n\t\t\t\t│   ├── App.vue\n\t\t\t\t│   └── ...\n\t\t\t\t└── store\n\t\t\t\t    ├── index.js          # 我们组装模块并导出 store 的地方\n\t\t\t\t    ├── actions.js        # 根级别的 action\n\t\t\t\t    ├── mutations.js      # 根级别的 mutation\n\t\t\t\t    └── modules\n\t\t\t\t        ├── cart.js       # 购物车模块\n\t\t\t\t        └── products.js   # 产品模块\n\t\t\t\t\t`,\n        codeDatas: [\n          {\n          \tword: 'State',\n            title: `单一状态树，即Vuex中的基本数据。用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。\n`,\n            \n            codes:[\n            \t{\n            \t\tsubtitle: '我们可以通过Vue的computed获得Vuex的state，如下：',\n            \t\tcode: \t`const store = new Vuex.Store({\n\t\t\t\t\t\t\t\t\t\t    state: {\n\t\t\t\t\t\t\t\t\t\t        count:0\n\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tconst app = new Vue({\n\t\t\t\t\t\t\t\t\t\t    //..\n\t\t\t\t\t\t\t\t\t\t    store,\n\t\t\t\t\t\t\t\t\t\t    computed: {\n\t\t\t\t\t\t\t\t\t\t        count: function(){\n\t\t\t\t\t\t\t\t\t\t            return this.$store.state.count\n\t\t\t\t\t\t\t\t\t\t        }\n\t\t\t\t\t\t\t\t\t\t    },\n\t\t\t\t\t\t\t\t\t\t    //..\n\t\t\t\t\t\t\t\t\t\t})`\t\n            \t}\n\n\n            ], \n            subWord: [\n            \t{\n            \t\ttitle: 'mapState辅助函数',\n            \t\tsubtitle: '当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。',\n            \t\tsubcode: `// 在单独构建的版本中辅助函数为 Vuex.mapState\n\t\t\t\t\timport { mapState } from 'vuex'\n\n\t\t\t\t\texport default {\n\t\t\t\t\t  // ...\n\t\t\t\t\t  computed: mapState({\n\t\t\t\t\t    // 箭头函数可使代码更简练\n\t\t\t\t\t    count: state => state.count,\n\n\t\t\t\t\t    // 传字符串参数 'count' 等同于 'state => state.count'\n\t\t\t\t\t    countAlias: 'count',\n\n\t\t\t\t\t    // 为了能够使用 'this' 获取局部状态，必须使用常规函数\n\t\t\t\t\t    countPlusLocalState (state) {\n\t\t\t\t\t      return state.count + this.localCount\n\t\t\t\t\t    }\n\t\t\t\t\t  })\n\t\t\t\t\t}\n\t\t\t\t`\n            \t}\n\n            ],\n\t\t\t\t\t\tsupplement: '每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。'\n          },\n          {\n          \tword: 'Getters',\n          \ttitle: `即从store的state中派生出的状态。`,\n          \tcodes: [\n          \t\t{\n          \t\t\tsubtitle: `getters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：`,\n\t\t          \tcode: `const store = new Vuex.Store({\n\t\t\t\t\t\t\t    state: {\n\t\t\t\t\t\t\t        count:0\n\t\t\t\t\t\t\t    }，\n\t\t\t\t\t\t\t    getters: {\n\t\t\t\t\t\t\t        // 单个参数\n\t\t\t\t\t\t\t        countDouble: function(state){\n\t\t\t\t\t\t\t            return state.count * 2\n\t\t\t\t\t\t\t        },\n\t\t\t\t\t\t\t        // 两个参数\n\t\t\t\t\t\t\t        countDoubleAndDouble: function(state, getters) {\n\t\t\t\t\t\t\t            return getters.countDouble * 2\n\t\t\t\t\t\t\t        }\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t`\n          \t\t},\n          \t\t{\n          \t\t\tsubtitle: `与state一样，我们也可以通过Vue的Computed获得Vuex的getters。`,\n\t\t          \tcode: `const app = new Vue({\n\t\t\t\t\t    //..\n\t\t\t\t\t    store,\n\t\t\t\t\t    computed: {\n\t\t\t\t\t        count: function(){\n\t\t\t\t\t            return this.$store.state.count\n\t\t\t\t\t        },\n\t\t\t\t\t        countDouble: function(){\n\t\t\t\t\t            return this.$store.getters.countDouble\n\t\t\t\t\t        },\n\t\t\t\t\t        countDoubleAndDouble: function(){\n\t\t\t\t\t            return this.$store.getters.countDoubleAndDouble\n\t\t\t\t\t        }\n\t\t\t\t\t    },\n\t\t\t\t\t    //..\n\t\t\t\t\t})`\n          \t\t}\n          \t],\n          \tsubWord: [\n          \t{\n          \t\ttitle: 'mapGetters 辅助函数',\n          \t\tsubtitle: 'mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，与state类似',\n          \t\tsubcode: `import { mapGetters } from 'vuex'\n\t\t\t\t\t\t\t\t\texport default {\n\t\t\t\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t\t\t\t  computed: {\n\t\t\t\t\t\t\t\t\t  // 使用对象展开运算符将 getters 混入 computed 对象中\n\t\t\t\t\t\t\t\t\t    ...mapGetters([\n\t\t\t\t\t\t\t\t\t      'countDouble',\n\t\t\t\t\t\t\t\t\t      'CountDoubleAndDouble',\n\t\t\t\t\t\t\t\t\t      //..\n\t\t\t\t\t\t\t\t\t    ])\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t`\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n          \t\t\n          \t\tsubtitle: '如果你想将一个 getter 属性另取一个名字，使用对象形式：',\n          \t\tsubcode: `mapGetters({\n\t\t\t\t\t  // 映射 this.double 为 store.getters.countDouble\n\t\t\t\t\t  double: 'countDouble'\n\t\t\t\t\t})\n\t\t\t\t\t\t\t\t`\n\t\t\t\t\t\t\t}\n          \t]\n\n          \t\n          \t\n          },\n          {\n          \tword: 'Mutations',\n          \ttitle: `提交mutation是更改Vuex中的store中的状态的唯一方法。`,\n          \tcodes: [\n          \t\t\t{\n          \t\t\t\tsubtitle: '更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数,提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。',\n          \t\t\t\tcode: `const store = new Vuex.Store({\n\t\t\t\t\t\t\t\t\t\t\t\t  state: {\n\t\t\t\t\t\t\t\t\t\t\t\t    count: 1\n\t\t\t\t\t\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t\t\t\t\t\t  mutations: {\n\t\t\t\t\t\t\t\t\t\t\t\t    //无提交荷载\n\t\t\t\t\t\t\t\t\t\t\t\t    increment(state) {\n\t\t\t\t\t\t\t\t\t\t\t\t        state.count++\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t    //提交荷载\n\t\t\t\t\t\t\t\t\t\t\t\t    increment(state, obj) {\n\t\t\t\t\t\t\t\t\t\t\t\t      state.count += obj.n\n\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t})`\n\n          \t\t\t},\n          \t\t\t{\n          \t\t\t\tsubtitle: `你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：`,\n          \t\t\t\t\tcode: `//无提交荷载\n\t\t\t\t\t\t\t\t\t\t\tstore.commit('increment')\n\t\t\t\t\t\t\t\t\t\t\t//提交荷载\n\t\t\t\t\t\t\t\t\t\t\tstore.commit('increment', {\n\t\t\t\t\t\t\t\t\t\t\t    n: 100\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t`\n\n          \t\t\t},\n          \t\t\t{\n          \t\t\t\tsubtitle: `在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：`,\n          \t\t\t\tcode: `// ...\n\t\t\t\t\t\t\t\t\t\tstore.commit({\n\t\t\t\t\t\t\t\t\t\t  type: 'increment',\n\t\t\t\t\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t\t\t\t\t})`\n          \t\t\t},\n          \t\t\t{\n          \t\t\t\tsubtitle: `当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：`,\n          \t\t\t\tcode: `mutations: {\n\t\t\t\t\t\t\t\t\t\t  increment (state, payload) {\n\t\t\t\t\t\t\t\t\t\t    state.count += payload.amount\n\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t}`\n          \t\t\t},\n          \t\t\t{\n          \t\t\t\tsubtitle: `使用常量替代 Mutation 事件类型--使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：`,\n          \t\t\t\tcode: `// mutation-types.js\n\t\t\t\t\texport const SOME_MUTATION = 'SOME_MUTATION'\n\t\t\t\t\t// store.js\n\t\t\t\t\timport Vuex from 'vuex'\n\t\t\t\t\timport { SOME_MUTATION } from './mutation-types'\n\n\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t  state: { ... },\n\t\t\t\t\t  mutations: {\n\t\t\t\t\t    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n\t\t\t\t\t    [SOME_MUTATION] (state) {\n\t\t\t\t\t      // mutate state\n\t\t\t\t\t    }\n\t\t\t\t\t  }\n\t\t\t\t\t})\n\t\t\t\t`\n          \t\t\t}\n          \t],\n          \tsubWord: [\n          \t\t{\n          \t\t\ttitle: '在组件中提交 Mutation',\n          \t\t\tsubtitle: `你可以在组件中使用 this.$store.commit('xxx') 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。\n\n`,\n          \t\t\tsubcode: `import { mapMutations } from 'vuex'\n\n\t\t\t\t\texport default {\n\t\t\t\t\t  // ...\n\t\t\t\t\t  methods: {\n\t\t\t\t\t    ...mapMutations([\n\t\t\t\t\t      'increment', // 将 'this.increment()' 映射为 'this.$store.commit('increment')'\n\n\t\t\t\t\t      // 'mapMutations' 也支持载荷：\n\t\t\t\t\t      'incrementBy' // 将 'this.incrementBy(amount)' 映射为 'this.$store.commit('incrementBy', amount)'\n\t\t\t\t\t    ]),\n\t\t\t\t\t    ...mapMutations({\n\t\t\t\t\t      add: 'increment' // 将 'this.add()' 映射为 'this.$store.commit('increment')'\n\t\t\t\t\t    })\n\t\t\t\t\t  }\n\t\t\t\t\t}`\n          \t\t}\n          \t]\n          },\n          {\n          \tword: 'Action',\n          \ttitle: 'Action 类似于 mutation，不同在于：',\n          \tcodes: [\n\t\t\t          \t{\n\t\t\t          \t\t\t\tsubtitle: `Action 提交的是 mutation，而不是直接变更状态。\n\t\t\t\t\t\t\t\t\t\t\t\t\tAction 可以包含任意异步操作。让我们来注册一个简单的 action：`,\n\t\t\t\t\t\t\t\t\t\t\t\tcode: `const store = new Vuex.Store({\n\t\t\t\t\t\t\t\t\t\t\t\t\t  state: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t    count: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t\t\t\t\t\t\t  mutations: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t    increment (state) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t      state.count++\n\t\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t\t\t\t\t\t\t  actions: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t    increment (context) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t      context.commit('increment')\n\t\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t\t`\n\t\t\t          \t},\n\t\t\t          \t{\n\t\t\t          \t\tsubtitle: `Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。`\n\n\t\t\t          \t},\n\t\t\t          \t{\n\t\t\t          \t\tsubtitle: `分发actions Action 通过 store.dispatch 方法触发：`,\n\t\t\t          \t\tcode: `store.dispatch('increment')`\n\t\t\t          \t}\n          \t\t\n          \t],\n          \tsubWord: [\n          \t\t{\n          \t\t\ttitle: '其他与mutations类似的地方',\n          \t\t\tsubtitle: `Actions 支持同样的载荷方式和对象方式进行分发：`,\n          \t\t\tsubcode: `// 以载荷形式分发\n\t\t\t\t\t\t\t\t\t\tstore.dispatch('increment', {\n\t\t\t\t\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t\t\t\t// 以对象形式分发\n\t\t\t\t\t\t\t\t\t\tstore.dispatch({\n\t\t\t\t\t\t\t\t\t\t  type: 'increment',\n\t\t\t\t\t\t\t\t\t\t  n: 10\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t`\n          \t\t},\n          \t\t{\n          \t\t\t\n          \t\t\tsubtitle: `来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：`,\n          \t\t\tsubcode: `actions: {\n\t\t\t\t\t  checkout ({ commit, state }, products) {\n\t\t\t\t\t    // 把当前购物车的物品备份起来\n\t\t\t\t\t    const savedCartItems = [...state.cart.added]\n\t\t\t\t\t    // 发出结账请求，然后乐观地清空购物车\n\t\t\t\t\t    commit(types.CHECKOUT_REQUEST)\n\t\t\t\t\t    // 购物 API 接受一个成功回调和一个失败回调\n\t\t\t\t\t    shop.buyProducts(\n\t\t\t\t\t      products,\n\t\t\t\t\t      // 成功操作\n\t\t\t\t\t      () => commit(types.CHECKOUT_SUCCESS),\n\t\t\t\t\t      // 失败操作\n\t\t\t\t\t      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n\t\t\t\t\t    )\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t\tsupplement: `注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。`\n          \t\t},\n          \t\t{\n          \t\t\ttitle: '在组件中分发 Action',\n          \t\t\tsubtitle: `你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：`,\n          \t\t\tsubcode: `import { mapActions } from 'vuex'\n\n\t\t\t\t\texport default {\n\t\t\t\t\t  // ...\n\t\t\t\t\t  methods: {\n\t\t\t\t\t    ...mapActions([\n\t\t\t\t\t      'increment', // 将 'this.increment()' 映射为 'this.$store.dispatch('increment')'\n\n\t\t\t\t\t      // 'mapActions' 也支持载荷：\n\t\t\t\t\t      'incrementBy' // 将 'this.incrementBy(amount)' 映射为 'this.$store.dispatch('incrementBy', amount)'\n\t\t\t\t\t    ]),\n\t\t\t\t\t    ...mapActions({\n\t\t\t\t\t      add: 'increment' // 将 'this.add()' 映射为 'this.$store.dispatch('increment')'\n\t\t\t\t\t    })\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t`\n          \t\t},\n          \t\t{\n          \t\t\ttitle: '组合 Action',\n          \t\t\tsubtitle: `Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n          \t\t\t首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：`,\n          \t\t\tsubcode: `actions: {\n\t\t\t\t\t\t\t\t\t  actionA ({ commit }) {\n\t\t\t\t\t\t\t\t\t    return new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\t      setTimeout(() => {\n\t\t\t\t\t\t\t\t\t        commit('someMutation')\n\t\t\t\t\t\t\t\t\t        resolve()\n\t\t\t\t\t\t\t\t\t      }, 1000)\n\t\t\t\t\t\t\t\t\t    })\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t}`\n          \t\t},\n          \t\t{\n          \t\t\tsubtitle: '现在你可以：',\n          \t\t\tsubcode: `store.dispatch('actionA').then(() => {\n\t\t\t\t\t\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t`\n          \t\t},\n          \t\t{\n          \t\t\tsubtitle: '在另外一个 action 中也可以：',\n          \t\t\tsubcode: `actions: {\n\t\t\t\t\t  // ...\n\t\t\t\t\t  actionB ({ dispatch, commit }) {\n\t\t\t\t\t    return dispatch('actionA').then(() => {\n\t\t\t\t\t      commit('someOtherMutation')\n\t\t\t\t\t    })\n\t\t\t\t\t  }\n\t\t\t\t\t}\t\t`\n          \t\t},\n          \t\t{\n          \t\t\tsubtitle: '最后，如果我们利用 async / await，我们可以如下组合 action：',\n          \t\t\tsubcode: `// 假设 getData() 和 getOtherData() 返回的是 Promise\n\n\t\t\t\t\tactions: {\n\t\t\t\t\t  async actionA ({ commit }) {\n\t\t\t\t\t    commit('gotData', await getData())\n\t\t\t\t\t  },\n\t\t\t\t\t  async actionB ({ dispatch, commit }) {\n\t\t\t\t\t    await dispatch('actionA') // 等待 actionA 完成\n\t\t\t\t\t    commit('gotOtherData', await getOtherData())\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t`,\n\t\t\t\tsupplement: `一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。`\n          \t\t}\n          \t]\n          },\n          {\n          \tword: 'Module',\n          \ttitle: '由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。',\n          \tcodes: [\n          \t\t{\n          \t\t\tsubtitle: `为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：`,\n          \t\t\tcode: `const moduleA = {\n\t\t\t\t\t\t\t\t\t\t  state: { ... },\n\t\t\t\t\t\t\t\t\t\t  mutations: { ... },\n\t\t\t\t\t\t\t\t\t\t  actions: { ... },\n\t\t\t\t\t\t\t\t\t\t  getters: { ... }\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tconst moduleB = {\n\t\t\t\t\t\t\t\t\t\t  state: { ... },\n\t\t\t\t\t\t\t\t\t\t  mutations: { ... },\n\t\t\t\t\t\t\t\t\t\t  actions: { ... }\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tconst store = new Vuex.Store({\n\t\t\t\t\t\t\t\t\t\t  modules: {\n\t\t\t\t\t\t\t\t\t\t    a: moduleA,\n\t\t\t\t\t\t\t\t\t\t    b: moduleB\n\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t\t\t\tstore.state.a // -> moduleA 的状态\n\t\t\t\t\t\t\t\t\t\tstore.state.b // -> moduleB 的状态`\n          \t\t}\n          \t],\n          \tsubWord: [\n          \t\t{ \n          \t\t\ttitle: '模块的局部状态',\n          \t\t\tsubtitle: `对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。`,\n          \t\t\tsubcode: `const moduleA = {\n\t\t\t\t\t  state: { count: 0 },\n\t\t\t\t\t  mutations: {\n\t\t\t\t\t    increment (state) {\n\t\t\t\t\t      // 这里的 'state' 对象是模块的局部状态\n\t\t\t\t\t      state.count++\n\t\t\t\t\t    }\n\t\t\t\t\t  },\n\n\t\t\t\t\t  getters: {\n\t\t\t\t\t    doubleCount (state) {\n\t\t\t\t\t      return state.count * 2\n\t\t\t\t\t    }\n\t\t\t\t\t  }\n\t\t\t\t\t}`\n  \n          \t\t},\n          \t\t{\n          \t\t\tsubtitle: `同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：`,\n\t\t\t\t        subcode: `const moduleA = {\n\t\t\t\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t\t\t\t  actions: {\n\t\t\t\t\t\t\t\t\t    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n\t\t\t\t\t\t\t\t\t      if ((state.count + rootState.count) % 2 === 1) {\n\t\t\t\t\t\t\t\t\t        commit('increment')\n\t\t\t\t\t\t\t\t\t      }\n\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t`\n          \t\t},\n          \t\t{\n          \t\t\tsubtitle: `对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：`,\n          \t\t\tsubcode: `const moduleA = {\n\t\t\t\t\t\t\t\t  // ...\n\t\t\t\t\t\t\t\t  getters: {\n\t\t\t\t\t\t\t\t    sumWithRootCount (state, getters, rootState) {\n\t\t\t\t\t\t\t\t      return state.count + rootState.count\n\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t`\n          \t\t}\n          \t]\n          }\n          ]\n\n\t\t\t})\n\t}\n</script>\n\n\n// WEBPACK FOOTER //\n// src/components/Javascript/Vuex.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-layout',{attrs:{\"row\":\"\",\"wrap\":\"\"}},[_c('v-flex',{attrs:{\"xs12\":\"\"}},[_c('v-card',[_c('v-toolbar',{attrs:{\"color\":\"pink\",\"dark\":\"\"}},[_c('v-toolbar-title',[_vm._v(\"Vuex学习心得\")]),_vm._v(\" \"),_c('v-spacer')],1)],1)],1),_vm._v(\" \"),_c('v-flex',{attrs:{\"xs12\":\"\"}},[_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n\\t      Vuex概念： Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\\n\\t    \")])],1),_vm._v(\" \"),_c('v-flex',{attrs:{\"xs12\":\"\",\"offset-xs1\":\"\"}},[_c('v-card',[_c('v-toolbar',{attrs:{\"color\":\"teal\",\"dark\":\"\"}},[_c('v-toolbar-title',{staticClass:\"text-xs-center\"},[_vm._v(\"什么是状态管理模式？\")])],1),_vm._v(\" \"),_c('v-list',{attrs:{\"subheader\":\"\"}},_vm._l((_vm.items),function(item,index){return _c('v-list-tile',{key:item.title,attrs:{\"avatar\":\"\"},on:{\"click\":function($event){}}},[_c('v-list-tile-content',{staticClass:\"pl-4\"},[_c('v-list-tile-title',[_vm._v(_vm._s(index+1)+\". \"+_vm._s(item.title))])],1)],1)})),_vm._v(\" \"),_c('v-divider'),_vm._v(\" \"),_c('v-subheader',[_vm._v(\"以下是一个表示 “单向数据流“理念的极简示意图\")])],1)],1),_vm._v(\" \"),_c('v-flex',{staticClass:\"mt-1\",attrs:{\"xs12\":\"\",\"sm6\":\"\",\"offset-xs1\":\"\"}},[_c('v-card',[_c('v-card-media',{attrs:{\"src\":\"https://vuex.vuejs.org/zh-cn/images/flow.png\",\"height\":\"400px\"}})],1)],1),_vm._v(\" \"),_c('v-flex',{staticClass:\"mt-1\",attrs:{\"xs12\":\"\",\"offset-xs1\":\"\"}},[_c('v-alert',{attrs:{\"type\":\"warning\",\"value\":true}},[_vm._v(\"\\n\\t\\t      注意： 但是，当我们的应用遇到多个组件共享状态时,单项数据流的简洁性很容易破坏：\\n\\t\\t    \")]),_vm._v(\" \"),_c('v-list',{attrs:{\"subheader\":\"\"}},[_c('v-list-tile',{attrs:{\"avatar\":\"\"},on:{\"click\":function($event){}}},[_c('v-list-tile-content',{staticClass:\"pl-4\"},[_c('v-list-tile-title',[_vm._v(\"问题1:多个视图依赖于同一状态。\")])],1)],1),_vm._v(\" \"),_c('v-list-tile',{attrs:{\"avatar\":\"\"},on:{\"click\":function($event){}}},[_c('v-list-tile-content',{staticClass:\"pl-4\"},[_c('v-list-tile-title',[_vm._v(\" 问题2:来自不同视图的行为需要变更同一状态。\")])],1)],1)],1),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n\\t     因此我们需要把组件的共享状态抽取出来，以一个全局单例模式管理，在这种模式下，我们组件树构成了一个巨大的”视图“，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\\n\\t    \")]),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n\\t    通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。\\n\\t  \")]),_vm._v(\" \"),_c('v-card',[_c('v-card-media',{attrs:{\"src\":\"https://vuex.vuejs.org/zh-cn/images/vuex.png\",\"height\":\"700px\"}})],1),_vm._v(\" \"),_c('v-toolbar',{attrs:{\"color\":\"teal\",\"dark\":\"\"}},[_c('v-toolbar-title',{staticClass:\"text-xs-center\"},[_vm._v(\"什么情况下我应该使用 Vuex？\")])],1),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"success\",\"value\":true}},[_vm._v(\"\\n        如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。\\n      \")]),_vm._v(\" \"),_c('v-toolbar',{attrs:{\"color\":\"teal\",\"dark\":\"\"}},[_c('v-toolbar-title',{staticClass:\"text-xs-center\"},[_vm._v(\"安装Vuex\")])],1),_vm._v(\" \"),_c('v-list',{attrs:{\"two-line\":\"\"}},[[_c('v-subheader',[_c('code',{staticClass:\"mr-2\"},[_vm._v(\"npm install vuex --save \")]),_vm._v(\" \"),_c('code',[_vm._v(\"yarn add vuex\")])])],_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"在store/index.js文件中引用vuex文件 并且使用use使用vuex\")]),_vm._v(\" \"),[_c('v-subheader',[_c('code',{staticClass:\"mr-2\"},[_vm._v(\"import Vue from 'vue'\")]),_vm._v(\" \"),_c('code',{staticClass:\"mr-2\"},[_vm._v(\"import Vuex from 'vuex'\")]),_vm._v(\" \"),_c('code',[_vm._v(\"Vue.use(Vuex)\")])])]],2),_vm._v(\" \"),_c('v-toolbar',{attrs:{\"color\":\"teal\",\"dark\":\"\"}},[_c('v-toolbar-title',{staticClass:\"text-xs-center\"},[_vm._v(\"Vuex核心概念\")])],1),_vm._v(\" \"),_c('v-list',[_c('v-list-tile',[_c('v-btn',{attrs:{\"color\":\"info\"}},[_vm._v(\"State\")]),_vm._v(\" \"),_c('v-btn',{attrs:{\"color\":\"info\"}},[_vm._v(\"Getter\")]),_vm._v(\" \"),_c('v-btn',{attrs:{\"color\":\"info\"}},[_vm._v(\"Mutation\")]),_vm._v(\" \"),_c('v-btn',{attrs:{\"color\":\"info\"}},[_vm._v(\"Action\")]),_vm._v(\" \"),_c('v-btn',{attrs:{\"color\":\"info\"}},[_vm._v(\"Module\")])],1)],1)],1),_vm._v(\" \"),_c('v-container',{attrs:{\"fluid\":\"\",\"grid-list-sm\":\"\",\"offset-sm-1\":\"\"}},[_c('v-layout',{attrs:{\"row\":\"\",\"wrap\":\"\"}},_vm._l((_vm.codeDatas),function(item,index){return _c('v-flex',{key:index,attrs:{\"d-flex\":\"\",\"xs12\":\"\"}},[_c('v-layout',{attrs:{\"column\":\"\"}},[_c('v-flex',{attrs:{\"d-flex\":\"\"}},[_c('v-card',{attrs:{\"color\":\"blue-grey\",\"dark\":\"\",\"tile\":\"\",\"flat\":\"\"}},[_c('v-card-text',[_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_c('v-btn',{attrs:{\"color\":\"indigo\"}},[_vm._v(_vm._s(item.word))]),_vm._v(_vm._s(item.title)+\"\\n    \\t \\t\\t\\t\\t\")],1),_vm._v(\" \"),_vm._l((item.codes),function(myItem,i){return _c('div',[_c('p',[_vm._v(_vm._s(myItem.subtitle))]),_vm._v(\" \"),(myItem.code)?_c('codemirror',{attrs:{\"value\":myItem.code}}):_vm._e(),_vm._v(\" \"),(item.supplement)?_c('v-alert',{attrs:{\"type\":\"warning\",\"value\":true}},[_vm._v(\"\\n    \\t \\t\\t\\t\\t\\t\\t\"+_vm._s(item.supplement)+\"\\n    \\t \\t\\t\\t\\t\")]):_vm._e()],1)}),_vm._v(\" \"),_vm._l((item.subWord),function(mySubWord,i){return _c('div',{key:i},[_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[(mySubWord.title)?_c('v-btn',{attrs:{\"color\":\"indigo\"}},[_vm._v(_vm._s(mySubWord.title))]):_vm._e(),_vm._v(_vm._s(mySubWord.subtitle)+\"\\n    \\t \\t\\t\\t\\t\")],1),_vm._v(\" \"),(mySubWord.subcode)?_c('codemirror',{attrs:{\"value\":mySubWord.subcode}}):_vm._e(),_vm._v(\" \"),(mySubWord.supplement)?_c('v-alert',{attrs:{\"type\":\"warning\",\"value\":true}},[_vm._v(\"\\n    \\t \\t\\t\\t\\t\\t\\t\"+_vm._s(mySubWord.supplement)+\"\\n    \\t \\t\\t\\t\\t\")]):_vm._e()],1)})],2)],1)],1)],1)],1)}))],1),_vm._v(\" \"),_c('v-flex',{attrs:{\"xs12\":\"\"}},[_c('v-card',[_c('v-toolbar',{attrs:{\"color\":\"teal\",\"dark\":\"\"}},[_c('v-toolbar-title',{staticClass:\"text-xs-center\"},[_vm._v(\"项目结构\")])],1),_vm._v(\" \"),_c('v-list',{attrs:{\"subheader\":\"\"}},_vm._l((_vm.vuexRules),function(item,index){return _c('v-list-tile',{key:item.title,attrs:{\"avatar\":\"\"},on:{\"click\":function($event){}}},[_c('v-list-tile-content',{staticClass:\"pl-4\"},[_c('v-list-tile-title',[_vm._v(_vm._s(index+1)+\". \"+_vm._s(item.title))])],1)],1)})),_vm._v(\" \"),_c('v-divider')],1),_vm._v(\" \"),_c('v-card',{attrs:{\"color\":\"blue-grey\",\"dark\":\"\",\"tile\":\"\",\"flat\":\"\"}},[_c('v-card-text',[_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n\\n    \\t \\t\\t\\t\\t\\t只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\\n    \\t \\t\\t\\t\\t\")]),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"warning\",\"value\":true}},[_vm._v(\"\\n    \\t \\t\\t\\t\\t对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\\n    \\t \\t\\t\\t\")]),_vm._v(\" \"),_c('codemirror',{attrs:{\"value\":_vm.ruleCode}})],1)],1)],1),_vm._v(\" \"),_c('v-flex',{attrs:{\"xs12\":\"\"}},[_c('v-card',[_c('v-toolbar',{attrs:{\"color\":\"teal\",\"dark\":\"\"}},[_c('v-toolbar-title',{staticClass:\"text-xs-center\"},[_vm._v(\"路由懒加载\")])],1),_vm._v(\" \"),_c('v-card-text',[_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n\\n    \\t \\t\\t\\t\\t\\t当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。\\n    \\t \\t\\t\\t\\t\")]),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"warning\",\"value\":true}},[_vm._v(\"\\n    \\t \\t\\t\\t\\t结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\\n    \\t \\t\\t\\t\")]),_vm._v(\" \"),_c('codemirror',{attrs:{\"value\":\"const Foo = () => Promise.resolve({ /* 组件定义对象 */ })\"}}),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n      \\t\\t\\t\\t\\t\\t\\t第二，在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)：\\n      \\t\\t\\t\\t\\t\")]),_vm._v(\" \"),_c('codemirror',{attrs:{\"value\":\"import('./Foo.vue') // 返回 Promise\"}}),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"warning\",\"value\":true}},[_vm._v(\"\\n    \\t \\t\\t\\t\\t注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。\\n    \\t \\t\\t\\t\")]),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n    \\t \\t\\t\\t\\t结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。\\n    \\t \\t\\t\\t\")]),_vm._v(\" \"),_c('codemirror',{attrs:{\"value\":\"const Foo = () => import('./Foo.vue')\"}}),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n    \\t \\t\\t\\t\\t在路由配置中什么都不需要改变，只需要像往常一样使用 Foo：\\n    \\t \\t\\t\\t\")]),_vm._v(\" \"),_c('codemirror',{attrs:{\"value\":\"const router = new VueRouter({\\n\\t\\t\\t\\t  routes: [\\n\\t\\t\\t\\t    { path: '/foo', component: Foo }\\n\\t\\t\\t\\t  ]\\n\\t\\t\\t\\t})\"}})],1)],1)],1),_vm._v(\" \"),_c('v-flex',{attrs:{\"xs12\":\"\"}},[_c('v-card',[_c('v-toolbar',{attrs:{\"color\":\"teal\",\"dark\":\"\"}},[_c('v-toolbar-title',{staticClass:\"text-xs-center\"},[_vm._v(\"把组件按组分块\")])],1),_vm._v(\" \"),_c('v-card-text',[_c('v-alert',{attrs:{\"type\":\"info\",\"value\":true}},[_vm._v(\"\\n\\n    \\t \\t\\t\\t\\t\\t有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack > 2.4)。\\n    \\t \\t\\t\\t\\t\")]),_vm._v(\" \"),_c('codemirror',{attrs:{\"value\":\"const Foo = () => import(/* webpackChunkName: 'group-foo' */ './Foo.vue')\\n\\t\\t\\t\\tconst Bar = () => import(/* webpackChunkName: 'group-foo' */ './Bar.vue')\\n\\t\\t\\t\\tconst Baz = () => import(/* webpackChunkName: 'group-foo' */ './Baz.vue')\\n\\t\\t\\t\"}}),_vm._v(\" \"),_c('v-alert',{attrs:{\"type\":\"warning\",\"value\":true}},[_vm._v(\"\\n    \\t \\t\\t\\t\\tWebpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。\\n    \\t \\t\\t\\t\")])],1)],1)],1)],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-2ddb6418\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/Javascript/Vuex.vue\n// module id = null\n// module chunks = ","var normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./Vuex.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./Vuex.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-2ddb6418\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./Vuex.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/Javascript/Vuex.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}